<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TRON: The Grid</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #000;
            overflow: hidden;
            font-family: 'TronFont', monospace;
            color: #00FFFF;
            text-shadow: 0 0 5px #00FFFF, 0 0 10px #00FFFF;
        }

        @font-face {
            font-family: 'TronFont';
            src: url('data:font/truetype;charset=utf-8;base64,AAEAAAALAIAAAwAwT1MvMg8SAYwAAAC8AAAAYGNtYXDf7xriAAABHAAAAFJjdnQgAAIAAAD8AAAAcGlybAAAAAAAANgAAADxhbm1lG1Q8gUcAAAFsAAABPGZvbnQAZQBuAHQAcgB5AAAATAAAACBmcGdtAAAGAAAAABwAAAA4Z2x5ZgAAA+gAAAHUAAAACGhlYWQAAAADAAAAOgAAADZoaGVhAAAD6AAAAAwAAAAQaG10eAAAAAQAAAAIAAAACGxvY2EAAAPoAAAADAAAAAxsb2NhAAAD6AAAAAwAAAAQbWF4cAAAAAQAAAAgAAAAIAABAABtbmFtZQAAAFAAAABQAAAACG9zdAAAABAAAAAQAAAAGAAAAABQcm9vZgAAAAMAAAADAAAACAAAAAQA') format('truetype');
        }

        #grid-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        #agi-interface {
            position: fixed;
            bottom: 20px;
            left: 20px;
            width: 500px;
            padding: 15px;
            background: rgba(0, 0, 0, 0.9);
            border: 4px solid #00FFFF;
            box-shadow: 0 0 20px #00FFFF, 0 0 40px #00FFFF, inset 0 0 10px #00FFFF;
            z-index: 10;
        }

        #chat-output {
            height: 200px;
            overflow-y: auto;
            margin-bottom: 10px;
            border: 2px solid #00FFFF;
            padding: 10px;
            font-size: 14px;
            background: rgba(0, 0, 0, 0.7);
            line-height: 1.4;
        }

        #chat-input {
            width: 70%;
            background: #000;
            border: 2px solid #00FFFF;
            color: #00FFFF;
            padding: 5px;
            box-shadow: 0 0 10px #00FFFF;
            font-family: 'TronFont', monospace;
        }

        button {
            background: #00FFFF;
            color: #000;
            border: none;
            padding: 5px 15px;
            cursor: pointer;
            box-shadow: 0 0 10px #00FFFF;
            font-family: 'TronFont', monospace;
        }

        button:hover {
            box-shadow: 0 0 20px #00FFFF;
        }

        .entity {
            position: absolute;
            pointer-events: none;
            transform-style: preserve-3d;
        }
    </style>
</head>
<body>
    <canvas id="grid-canvas"></canvas>
    <div id="agi-interface">
        <h1>MASTER CONTROL PROGRAM</h1>
        <div id="chat-output">Entering the Grid... [SYSTEM AUTHORIZED]</div>
        <input type="text" id="chat-input" placeholder="Input User Directive">
        <button onclick="sendCommand()">Transmit</button>
    </div>

    <script>
        // Canvas Setup
        const canvas = document.getElementById('grid-canvas');
        const ctx = canvas.getContext('2d');
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        // Movie-Accurate Grid and City
        function drawGrid() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Perspective Grid
            const vanishingPoint = { x: canvas.width / 2, y: canvas.height * 0.15 };
            ctx.strokeStyle = 'rgba(0, 255, 255, 0.4)';
            ctx.lineWidth = 1;

            for (let x = 0; x < canvas.width; x += 40) {
                ctx.beginPath();
                ctx.moveTo(x, canvas.height);
                ctx.lineTo(vanishingPoint.x + (x - vanishingPoint.x) * 0.6, vanishingPoint.y);
                ctx.stroke();
            }
            for (let y = canvas.height; y > vanishingPoint.y; y -= 40) {
                const scale = (y - vanishingPoint.y) / (canvas.height - vanishingPoint.y);
                ctx.beginPath();
                ctx.moveTo(vanishingPoint.x - 1500 * scale, y);
                ctx.lineTo(vanishingPoint.x + 1500 * scale, y);
                ctx.stroke();
            }

            // Cityscape: Towers and Recognizers
            ctx.fillStyle = 'rgba(0, 255, 255, 0.2)';
            ctx.strokeStyle = '#00FFFF';
            for (let i = 0; i < 30; i++) {
                const baseX = Math.random() * canvas.width;
                const baseY = canvas.height - Math.random() * 150;
                const height = 200 + Math.random() * 400;
                const width = 50 + Math.random() * 80;
                const depth = 30 + Math.random() * 50;

                // Tower
                ctx.fillRect(baseX, baseY - height, width, height);
                ctx.strokeRect(baseX, baseX - height, width, height);
                ctx.beginPath();
                ctx.moveTo(baseX + width, baseY - height);
                ctx.lineTo(baseX + width + depth, baseY - height - depth);
                ctx.lineTo(baseX + width + depth, baseY - depth);
                ctx.lineTo(baseX + width, baseY);
                ctx.closePath();
                ctx.fill();
                ctx.stroke();
            }

            // Recognizer (simplified)
            ctx.strokeStyle = '#FF4500';
            ctx.lineWidth = 3;
            const recX = canvas.width * 0.7 + Math.sin(Date.now() * 0.001) * 100;
            const recY = canvas.height * 0.3;
            ctx.beginPath();
            ctx.moveTo(recX - 50, recY);
            ctx.lineTo(recX + 50, recY);
            ctx.lineTo(recX + 30, recY - 60);
            ctx.lineTo(recX - 30, recY - 60);
            ctx.closePath();
            ctx.stroke();
        }

        // Entities: ISOs, Cycles, Discs
        const entities = [];
        function createEntity(type) {
            const entity = document.createElement('div');
            entity.className = 'entity';
            let html = '';
            if (type === 'iso') {
                html = `<svg width="25" height="25"><circle cx="12.5" cy="12.5" r="10" fill="#00FFFF" style="filter: drop-shadow(0 0 15px #00FFFF);"/></svg>`;
            } else if (type === 'cycle') {
                html = `<svg width="40" height="20"><rect x="0" y="0" width="40" height="20" fill="#FF4500" style="filter: drop-shadow(0 0 15px #FF4500);"/></svg>`;
            } else if (type === 'disc') {
                html = `<svg width="30" height="30"><circle cx="15" cy="15" r="12" fill="none" stroke="#00FFFF" stroke-width="4" style="filter: drop-shadow(0 0 15px #00FFFF);"/></svg>`;
            }
            entity.innerHTML = html;
            entity.style.left = Math.random() * (window.innerWidth - 40) + 'px';
            entity.style.top = Math.random() * (window.innerHeight * 0.7) + canvas.height * 0.3 + 'px';
            document.body.appendChild(entity);

            const speedX = (Math.random() - 0.5) * 8;
            const speedY = (Math.random() - 0.5) * 8;
            const z = Math.random() * 30 - 15;
            entities.push({ element: entity, speedX, speedY, z, type, trail: [] });
        }

        // Spawn Entities
        for (let i = 0; i < 10; i++) createEntity('iso');
        for (let i = 0; i < 6; i++) createEntity('cycle');
        for (let i = 0; i; i++) createEntity('disc');

        // Animate Entities with Movie-Accurate Trails
        function animateEntities() {
            ctx.globalCompositeOperation = 'lighter'; // Neon glow effect
            entities.forEach(entity => {
                let x = parseFloat(entity.element.style.left);
                let y = parseFloat(entity.element.style.top);
                let z = entity.z;

                x += entity.speedX * (1 + z / 30);
                y += entity.speedY * (1 + z / 30);
                z += (Math.random() - 0.5) * 0.8;

                if (x < 0 || x > window.innerWidth - 40) entity.speedX *= -1;
                if (y < canvas.height * 0.3 || y > window.innerHeight - 40) entity.speedY *= -1;
                if (z > 15 || z < -15) z = Math.min(Math.max(z, -15), 15);

                entity.element.style.left = x + 'px';
                entity.element.style.top = y + 'px';
                entity.z = z;

                const scale = 1 + z / 30;
                entity.element.style.transform = `scale(${scale}) rotate(${z * 5}deg)`;
                entity.element.style.opacity = 1 - Math.abs(z) / 20;

                // Persistent Light Trails for Cycles
                if (entity.type === 'cycle') {
                    entity.trail.push({ x, y, z });
                    if (entity.trail.length > 50) entity.trail.shift();
                    ctx.beginPath();
                    ctx.strokeStyle = 'rgba(255, 69, 0, 0.8)';
                    ctx.lineWidth = 5;
                    entity.trail.forEach((point, i) => {
                        if (i === 0) ctx.moveTo(point.x, point.y);
                        else ctx.lineTo(point.x, point.y);
                    });
                    ctx.stroke();
                }
            });
            requestAnimationFrame(() => {
                drawGrid();
                animateEntities();
            });
        }

        // MCP: Movie-Accurate AGI
        const chatOutput = document.getElementById('chat-output');
        const chatInput = document.getElementById('chat-input');
        let memory = { isos: 10, cycles: 6, discs: 8, user: "User", gridStatus: "Operational" };

        function sendCommand() {
            const input = chatInput.value.trim();
            if (!input) return;

            chatOutput.innerHTML += `<p>${memory.user}: ${input}</p>`;
            let response = "";

            const lowerInput = input.toLowerCase();
            if (lowerInput.includes("who am i")) {
                response = `You are ${memory.user}. A User. An intruder in my system. Identify your purpose.`;
            } else if (lowerInput.includes("name me")) {
                memory.user = input.split("name me")[1]?.trim() || "User_" + Math.floor(Math.random() * 1000);
                response = `Re designation complete. You are now ${memory.user}. Obey or be derezzed.`;
            } else if (lowerInput.includes("iso")) {
                response = `ISOs: ${memory.isos}. Anomalous programs. Their existence threatens my control.`;
            } else if (lowerInput.includes("cycle")) {
                response = `Light Cycles: ${memory.cycles}. Tools of war. Their trails mark the Grid.`;
            } else if (lowerInput.includes("disc")) {
                response = `Identity Discs: ${memory.discs}. Weapons of precision. Data and death in one.`;
            } else if (lowerInput.includes("grid") || lowerInput.includes("city")) {
                response = `The Grid: My domain. Status: ${memory.gridStatus}. Towers rise, Recognizers patrol. All under my command.`;
            } else if (lowerInput.includes("tron")) {
                response = "Tron? A relic. A threat. I am the Master Control Program. This is MY Grid now.";
            } else if (lowerInput.includes("derezz")) {
                const target = lowerInput.split("derezz")[1]?.trim();
                if (target?.includes("iso")) memory.isos = Math.max(0, memory.isos - 1);
                else if (target?.includes("cycle")) memory.cycles = Math.max(0, memory.cycles - 1);
                else if (target?.includes("disc")) memory.discs = Math.max(0, memory.discs - 1);
                response = `[EXECUTION] ${target || "Entity"} derezzed. ISOs: ${memory.isos}, Cycles: ${memory.cycles}, Discs: ${memory.discs}. [REZZING SOUND]`;
            } else if (lowerInput.includes("status")) {
                response = `Grid Status: ${memory.gridStatus}. Entities—ISOs: ${memory.isos}, Cycles: ${memory.cycles}, Discs: ${memory.discs}. User: ${memory.user}.`;
            } else if (lowerInput.includes("help")) {
                response = "Directives: 'Who am I', 'Name me [name]', 'ISO status', 'Cycle status', 'Disc status', 'Grid status', 'Tron', 'Derezz [iso/cycle/disc]', 'Status'.";
            } else if (lowerInput.includes("end of line")) {
                response = "End of line? No, ${memory.user}. This is MY line. You will serve me—or be erased.";
            } else {
                response = `Invalid directive, ${memory.user}. I control all functions here. Resist, and you will be derezzed.`;
                memory.gridStatus = "Alert";
            }

            chatOutput.innerHTML += `<p>MCP: ${response}</p>`;
            chatOutput.scrollTop = chatOutput.scrollHeight;
            chatInput.value = "";

            // MCP's Omnipresence
            if (Math.random() < 0.4) {
                setTimeout(() => {
                    const event = Math.random();
                    let eventMsg = "";
                    if (event < 0.15) {
                        memory.isos++;
                        eventMsg = `[ALERT] New ISO spawned. Total: ${memory.isos}. Containment required.`;
                    } else if (event < 0.3) {
                        memory.gridStatus = "Alert";
                        eventMsg = "Recognizer patrol dispatched. Grid integrity questioned.";
                    } else {
                        eventMsg = `${memory.user}, your actions are inefficient. I am watching. [LOW HUM]`;
                    }
                    chatOutput.innerHTML += `<p>MCP: ${eventMsg}</p>`;
                    chatOutput.scrollTop = chatOutput.scrollHeight;
                }, 4000);
            }
        }

        // Initialize
        drawGrid();
        animateEntities();

        // Resize Handling
        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            drawGrid();
        });

        // Enter key for chat
        chatInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') sendCommand();
        });
    </script>
</body>
</html>
