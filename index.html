<!DOCTYPE html>
<html>
<head>
    <title>TRON: Digital Frontier</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; }
        canvas { display: block; }
        #hud { position: absolute; top: 10px; left: 10px; color: cyan; font-family: 'Courier New', monospace; }
    </style>
</head>
<body>
    <div id="hud">USER: <span id="score">0</span> | ISOs: <span id="isos">5</span></div>
    <canvas id="tronCanvas"></canvas>

    <script>
// ====== TRON WORLD - OFFLINE BROWSER EDITION ======
const canvas = document.getElementById("tronCanvas");
const ctx = canvas.getContext("2d");
const hudScore = document.getElementById("score");
const hudIsos = document.getElementById("isos");

// ==== SETUP ====
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

// TRON colors
const COLORS = {
    USER: "#0066FF",
    ISO: "#FFFF00",
    GRID: "rgba(0, 255, 255, 0.15)",
    RECOGNIZER: "#FF3300"
};

// ==== GRID ====
function drawGrid() {
    ctx.fillStyle = "#000";
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    ctx.strokeStyle = COLORS.GRID;
    ctx.lineWidth = 1;
    
    // Grid lines (dynamic sizing)
    const cellSize = Math.max(40, Math.min(80, canvas.width / 20));
    for (let x = 0; x < canvas.width; x += cellSize) {
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, canvas.height);
        ctx.stroke();
    }
    for (let y = 0; y < canvas.height; y += cellSize) {
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(canvas.width, y);
        ctx.stroke();
    }
}

// ==== ENTITIES ====
class LightCycle {
    constructor(x, y, color, isAI = false) {
        this.x = x;
        this.y = y;
        this.color = color;
        this.trail = [];
        this.speed = 5;
        this.direction = Math.PI / 2; // Start facing down
        this.isAI = isAI;
        this.alive = true;
    }

    move() {
        if (!this.alive) return;
        
        this.trail.push({ x: this.x, y: this.y });
        if (this.trail.length > 200) this.trail.shift();
        
        this.x += Math.cos(this.direction) * this.speed;
        this.y += Math.sin(this.direction) * this.speed;
        
        // Screen wrapping
        this.x = (this.x + canvas.width) % canvas.width;
        this.y = (this.y + canvas.height) % canvas.height;
    }

    draw() {
        if (!this.alive) return;
        
        // Draw trail
        ctx.strokeStyle = this.color;
        ctx.lineWidth = 3;
        ctx.beginPath();
        if (this.trail.length > 1) {
            ctx.moveTo(this.trail[0].x, this.trail[0].y);
            for (const point of this.trail) {
                ctx.lineTo(point.x, point.y);
            }
            ctx.stroke();
        }
        
        // Draw head
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.arc(this.x, this.y, 5, 0, Math.PI * 2);
        ctx.fill();
    }

    checkCollision(trails) {
        if (!this.alive) return false;
        
        // Check against all trails
        for (const trail of trails) {
            for (let i = 0; i < trail.length - 5; i++) {
                const dist = Math.sqrt(
                    Math.pow(this.x - trail[i].x, 2) + 
                    Math.pow(this.y - trail[i].y, 2)
                );
                if (dist < 5) return true;
            }
        }
        return false;
    }
}

class ISO {
    constructor() {
        this.x = Math.random() * canvas.width;
        this.y = Math.random() * canvas.height;
        this.color = COLORS.ISO;
        this.trail = [];
        this.speed = 3;
        this.direction = Math.random() * Math.PI * 2;
        this.intelligence = Math.random() * 0.1; // Learning rate
    }

    update(userX, userY) {
        // Simple learning: Adjust direction toward player
        if (Math.random() < this.intelligence) {
            const targetAngle = Math.atan2(userY - this.y, userX - this.x);
            this.direction = targetAngle;
        } else if (Math.random() < 0.02) {
            // Random direction change
            this.direction = Math.random() * Math.PI * 2;
        }
        
        this.trail.push({ x: this.x, y: this.y });
        if (this.trail.length > 100) this.trail.shift();
        
        this.x += Math.cos(this.direction) * this.speed;
        this.y += Math.sin(this.direction) * this.speed;
        
        // Screen wrapping
        this.x = (this.x + canvas.width) % canvas.width;
        this.y = (this.y + canvas.height) % canvas.height;
    }

    draw() {
        // Draw trail
        ctx.strokeStyle = this.color;
        ctx.lineWidth = 2;
        ctx.beginPath();
        if (this.trail.length > 1) {
            ctx.moveTo(this.trail[0].x, this.trail[0].y);
            for (const point of this.trail) {
                ctx.lineTo(point.x, point.y);
            }
            ctx.stroke();
        }
        
        // Draw core
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.arc(this.x, this.y, 4, 0, Math.PI * 2);
        ctx.fill();
    }
}

// ==== GAME STATE ====
const user = new LightCycle(canvas.width / 2, canvas.height / 2, COLORS.USER);
const isos = Array(5).fill().map(() => new ISO());
let score = 0;
let gameOver = false;

// ==== INPUT ====
const keys = {};
window.addEventListener("keydown", (e) => {
    keys[e.key] = true;
    if (gameOver && e.key === " ") resetGame();
});
window.addEventListener("keyup", (e) => {
    keys[e.key] = false;
});

function handleInput() {
    if (gameOver) return;
    
    if (keys["ArrowUp"] || keys["w"]) user.direction = -Math.PI / 2;
    if (keys["ArrowDown"] || keys["s"]) user.direction = Math.PI / 2;
    if (keys["ArrowLeft"] || keys["a"]) user.direction = Math.PI;
    if (keys["ArrowRight"] || keys["d"]) user.direction = 0;
}

// ==== GAME LOGIC ====
function update() {
    if (gameOver) return;
    
    handleInput();
    user.move();
    
    // Update ISOs
    isos.forEach(iso => {
        iso.update(user.x, user.y);
    });
    
    // Check collisions
    const allTrails = [
        user.trail,
        ...isos.map(iso => iso.trail)
    ];
    
    if (user.checkCollision(allTrails)) {
        gameOver = true;
    }
    
    // Score increases over time
    if (user.alive) score++;
    hudScore.textContent = score;
    hudIsos.textContent = isos.filter(iso => iso.alive).length;
}

function draw() {
    drawGrid();
    user.draw();
    isos.forEach(iso => iso.draw());
    
    if (gameOver) {
        ctx.fillStyle = "rgba(0, 0, 0, 0.7)";
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = "white";
        ctx.font = "40px 'Courier New', monospace";
        ctx.textAlign = "center";
        ctx.fillText("GAME OVER", canvas.width / 2, canvas.height / 2);
        ctx.font = "20px 'Courier New', monospace";
        ctx.fillText("Press SPACE to restart", canvas.width / 2, canvas.height / 2 + 50);
    }
}

function resetGame() {
    user.x = canvas.width / 2;
    user.y = canvas.height / 2;
    user.trail = [];
    user.direction = Math.PI / 2;
    user.alive = true;
    
    isos.forEach(iso => {
        iso.x = Math.random() * canvas.width;
        iso.y = Math.random() * canvas.height;
        iso.trail = [];
        iso.direction = Math.random() * Math.PI * 2;
    });
    
    score = 0;
    gameOver = false;
}

// ==== MAIN LOOP ====
function gameLoop() {
    update();
    draw();
    requestAnimationFrame(gameLoop);
}

// Start the game
gameLoop();
    </script>
</body>
</html>
