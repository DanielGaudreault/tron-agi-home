<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TRON: Grid Revolution</title>
    <style>
        /* === GLOBAL STYLES === */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Courier New', monospace;
            background-color: #000;
            color: #00ffff;
            overflow: hidden;
            height: 100vh;
            -webkit-tap-highlight-color: transparent;
        }

        /* === START SCREEN === */
        #start-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(ellipse at center, rgba(0,20,40,0.95) 0%, rgba(0,0,30,0.98) 100%);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
            user-select: none;
        }

        .title-container {
            text-align: center;
            margin-bottom: 40px;
            animation: float 6s ease-in-out infinite;
        }

        .title-glitch {
            font-size: 5rem;
            text-transform: uppercase;
            letter-spacing: 10px;
            color: #00ffff;
            text-shadow: 0 0 15px #00ffff, 0 0 30px #00ffff;
            margin-bottom: 20px;
            position: relative;
        }

        .title-glitch::before, .title-glitch::after {
            content: "TRON";
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            opacity: 0.8;
        }

        .title-glitch::before {
            color: #ff00ff;
            z-index: -1;
            animation: glitch-effect 3s infinite;
        }

        .title-glitch::after {
            color: #ffff00;
            z-index: -2;
            animation: glitch-effect 2s infinite reverse;
        }

        .subtitle {
            font-size: 1.5rem;
            letter-spacing: 5px;
            color: rgba(0, 255, 255, 0.8);
            text-shadow: 0 0 10px #00ffff;
        }

        .form-container {
            background-color: rgba(0, 30, 60, 0.6);
            border: 1px solid #00ffff;
            box-shadow: 0 0 30px rgba(0, 255, 255, 0.3);
            padding: 30px;
            width: 400px;
            max-width: 90%;
            border-radius: 5px;
        }

        #player-name {
            width: 100%;
            padding: 12px 15px;
            margin-bottom: 20px;
            background-color: rgba(0, 20, 40, 0.8);
            border: 1px solid #00ffff;
            color: #00ffff;
            font-family: 'Courier New', monospace;
            font-size: 16px;
            text-align: center;
            outline: none;
            transition: all 0.3s;
        }

        #player-name:focus {
            box-shadow: 0 0 15px #00ffff;
            background-color: rgba(0, 40, 80, 0.9);
        }

        #enter-button {
            width: 100%;
            padding: 15px;
            background: linear-gradient(to right, rgba(0, 80, 160, 0.8), rgba(0, 160, 220, 0.6));
            border: 1px solid #00ffff;
            color: #00ffff;
            font-family: 'Courier New', monospace;
            font-size: 18px;
            letter-spacing: 2px;
            text-transform: uppercase;
            cursor: pointer;
            transition: all 0.3s;
        }

        #enter-button:hover {
            background: linear-gradient(to right, rgba(0, 120, 220, 0.9), rgba(0, 200, 255, 0.7));
            box-shadow: 0 0 20px #00ffff;
            transform: translateY(-2px);
        }

        /* === GAME UI === */
        #game-ui {
            position: fixed;
            top: 20px;
            left: 20px;
            z-index: 10;
            color: #00ffff;
            font-size: 14px;
            text-shadow: 0 0 5px #00ffff;
            opacity: 0;
            transition: opacity 1s;
            pointer-events: none;
            user-select: none;
        }

        #game-ui.active {
            opacity: 1;
        }

        .player-info {
            background-color: rgba(0, 20, 40, 0.7);
            border: 1px solid #00ffff;
            padding: 15px;
            margin-bottom: 15px;
            border-radius: 5px;
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.3);
        }

        .player-name {
            font-size: 18px;
            letter-spacing: 2px;
            margin-bottom: 5px;
        }

        .player-score {
            font-size: 16px;
            color: rgba(0, 255, 255, 0.8);
        }

        .game-stats {
            background-color: rgba(0, 20, 40, 0.7);
            border: 1px solid #00ffff;
            padding: 15px;
            border-radius: 5px;
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.3);
        }

        .stat {
            margin-bottom: 8px;
            display: flex;
            justify-content: space-between;
        }

        .stat:last-child {
            margin-bottom: 0;
        }

        .stat span:first-child {
            color: rgba(0, 255, 255, 0.7);
        }

        /* === MOBILE CONTROLS === */
        #mobile-controls {
            position: fixed;
            bottom: 20px;
            right: 20px;
            display: none;
            grid-template-columns: repeat(3, 60px);
            grid-template-rows: repeat(3, 60px);
            gap: 5px;
            z-index: 20;
        }

        .mobile-btn {
            background: rgba(0, 100, 200, 0.3);
            border: 1px solid #00ffff;
            color: #00ffff;
            font-size: 24px;
            display: flex;
            justify-content: center;
            align-items: center;
            border-radius: 5px;
            touch-action: manipulation;
        }

        .mobile-btn:active {
            background: rgba(0, 200, 255, 0.5);
        }

        #up-btn { grid-column: 2; grid-row: 1; }
        #left-btn { grid-column: 1; grid-row: 2; }
        #down-btn { grid-column: 2; grid-row: 3; }
        #right-btn { grid-column: 3; grid-row: 2; }

        /* === ANIMATIONS === */
        @keyframes float {
            0% { transform: translateY(0px); }
            50% { transform: translateY(-15px); }
            100% { transform: translateY(0px); }
        }

        @keyframes glitch-effect {
            0% { transform: translate(0); }
            20% { transform: translate(-3px, 3px); }
            40% { transform: translate(-3px, -3px); }
            60% { transform: translate(3px, 3px); }
            80% { transform: translate(3px, -3px); }
            100% { transform: translate(0); }
        }

        /* === RESPONSIVE DESIGN === */
        @media (max-width: 768px) {
            .title-glitch {
                font-size: 3rem;
                letter-spacing: 5px;
            }
            
            .subtitle {
                font-size: 1rem;
            }
            
            .form-container {
                padding: 25px;
                width: 90%;
            }
            
            #game-ui {
                font-size: 12px;
                top: 10px;
                left: 10px;
            }
            
            .player-info, .game-stats {
                padding: 10px;
            }

            #mobile-controls {
                display: grid;
            }
        }
    </style>
</head>
<body>
    <div id="start-screen">
        <div class="title-container">
            <h1 class="title-glitch">TRON</h1>
            <h2 class="subtitle">GRID REVOLUTION</h2>
        </div>
        <div class="form-container">
            <input type="text" id="player-name" placeholder="ENTER USERNAME" maxlength="12">
            <button id="enter-button">INITIALIZE</button>
        </div>
    </div>
    
    <div id="game-ui">
        <div class="player-info">
            <div class="player-name"></div>
            <div class="player-score">SPEED: 100%</div>
        </div>
        <div class="game-stats">
            <div class="stat"><span>PLAYERS:</span> <span id="player-count">1</span></div>
            <div class="stat"><span>POSITION:</span> <span id="player-position">0,0</span></div>
            <div class="stat"><span>TRAIL LENGTH:</span> <span id="trail-length">0</span></div>
        </div>
    </div>

    <div id="mobile-controls">
        <div class="mobile-btn" id="up-btn">↑</div>
        <div class="mobile-btn" id="left-btn">←</div>
        <div class="mobile-btn" id="down-btn">↓</div>
        <div class="mobile-btn" id="right-btn">→</div>
    </div>
    
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
    <script>
        // Enhanced Game Configuration
        const CONFIG = {
            gridSize: 120,
            cellSize: 2,
            gridColor: 0x003300,
            lightColor: 0x00ffff,
            buildingColors: [0x111122, 0x112211, 0x221111, 0x121212],
            playerColors: [0x00ffff, 0xff00ff, 0xffff00, 0xff8800],
            moveSpeed: 0.15,
            wallHeight: 2.5,
            wallOpacity: 0.85,
            fov: 80,
            cameraDistance: 35,
            cameraHeight: 20,
            maxWalls: 300,
            wallSegmentDistance: 0.5,
            aiTurnFrequency: 120,
            speedBoostMultiplier: 1.5,
            boostDuration: 3000
        };

        // Game State
        const gameState = {
            players: {},
            walls: [],
            buildings: [],
            powerUps: [],
            myPlayerId: null,
            gameStarted: false,
            keys: {},
            lastTime: 0,
            isMobile: /Mobi|Android/i.test(navigator.userAgent),
            score: 0
        };

        // Three.js Setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x000011);
        const camera = new THREE.PerspectiveCamera(
            CONFIG.fov, 
            window.innerWidth / window.innerHeight, 
            0.1, 
            1000
        );
        const renderer = new THREE.WebGLRenderer({ 
            antialias: true,
            powerPreference: "high-performance"
        });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderer.domElement);

        // Enhanced Lighting
        const ambientLight = new THREE.AmbientLight(0x222222);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0x00ffff, 1.2);
        directionalLight.position.set(1, 2, 1);
        directionalLight.castShadow = true;
        directionalLight.shadow.mapSize.width = 2048;
        directionalLight.shadow.mapSize.height = 2048;
        scene.add(directionalLight);

        // Grid Helper Function
        function createGrid() {
            const grid = new THREE.Group();
            
            // Ground plane with better material
            const groundGeometry = new THREE.PlaneGeometry(
                CONFIG.gridSize * CONFIG.cellSize, 
                CONFIG.gridSize * CONFIG.cellSize,
                CONFIG.gridSize,
                CONFIG.gridSize
            );
            
            const groundMaterial = new THREE.MeshPhongMaterial({ 
                color: CONFIG.gridColor,
                emissive: 0x001100,
                emissiveIntensity: 0.5,
                side: THREE.DoubleSide,
                shininess: 100
            });
            
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            grid.add(ground);
            
            // Grid lines with glow effect
            const gridHelper = new THREE.GridHelper(
                CONFIG.gridSize * CONFIG.cellSize,
                CONFIG.gridSize,
                CONFIG.lightColor,
                new THREE.Color(CONFIG.lightColor).multiplyScalar(0.7)
            );
            gridHelper.position.y = 0.1;
            grid.add(gridHelper);
            
            // Add subtle grid pulse animation
            let pulseIntensity = 0;
            function animateGrid() {
                pulseIntensity = 0.2 * Math.sin(Date.now() * 0.001) + 0.8;
                gridHelper.material.opacity = pulseIntensity * 0.6;
                requestAnimationFrame(animateGrid);
            }
            animateGrid();
            
            return grid;
        }

        // Enhanced Building Generation
        function createBuildings() {
            const halfSize = CONFIG.gridSize / 2;
            const exclusionZone = 15; // Center area without buildings
            
            for (let i = 0; i < 40; i++) {
                const x = Math.floor(Math.random() * (CONFIG.gridSize - exclusionZone * 2) - halfSize + exclusionZone);
                const z = Math.floor(Math.random() * (CONFIG.gridSize - exclusionZone * 2) - halfSize + exclusionZone);
                
                const width = Math.floor(Math.random() * 6) + 3;
                const depth = Math.floor(Math.random() * 6) + 3;
                const height = Math.floor(Math.random() * 12) + 6;
                const color = CONFIG.buildingColors[Math.floor(Math.random() * CONFIG.buildingColors.length)];
                
                // Create building with better geometry
                const geometry = new THREE.BoxGeometry(width, height, depth);
                const material = new THREE.MeshPhongMaterial({
                    color: color,
                    emissive: 0x001111,
                    emissiveIntensity: 0.3,
                    transparent: true,
                    opacity: 0.85,
                    shininess: 50
                });
                
                const building = new THREE.Mesh(geometry, material);
                building.position.set(x, height/2, z);
                building.castShadow = true;
                building.receiveShadow = true;
                scene.add(building);
                
                // Add glowing edges
                const edges = new THREE.EdgesGeometry(geometry);
                const lineMaterial = new THREE.LineBasicMaterial({ 
                    color: CONFIG.lightColor,
                    linewidth: 2
                });
                const line = new THREE.LineSegments(edges, lineMaterial);
                line.position.copy(building.position);
                scene.add(line);
                
                gameState.buildings.push(building);
            }
        }

        // Enhanced Player Creation
        function createPlayer(color, isAI = false) {
            const group = new THREE.Group();
            
            // Body with better geometry
            const bodyGeometry = new THREE.CylinderGeometry(0.7, 0.5, 2.5, 8);
            const bodyMaterial = new THREE.MeshPhongMaterial({
                color: color,
                emissive: color,
                emissiveIntensity: 0.8,
                shininess: 100
            });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.rotation.x = Math.PI / 2;
            group.add(body);
            
            // Head with better geometry
            const headGeometry = new THREE.SphereGeometry(0.6, 16, 16);
            const headMaterial = new THREE.MeshPhongMaterial({
                color: color,
                emissive: color,
                emissiveIntensity: 0.5
            });
            const head = new THREE.Mesh(headGeometry, headMaterial);
            head.position.set(0, 0, 1.2);
            group.add(head);
            
            // Trail with particle effect
            const trailGeometry = new THREE.ConeGeometry(0.3, 2, 6);
            const trailMaterial = new THREE.MeshPhongMaterial({
                color: color,
                emissive: color,
                transparent: true,
                opacity: 0.7,
                blending: THREE.AdditiveBlending
            });
            const trail = new THREE.Mesh(trailGeometry, trailMaterial);
            trail.rotation.x = Math.PI;
            trail.position.set(0, 0, -1.5);
            group.add(trail);
            
            // Add glow effect for player
            if (!isAI) {
                const glowGeometry = new THREE.SphereGeometry(1.2, 16, 16);
                const glowMaterial = new THREE.MeshBasicMaterial({
                    color: color,
                    transparent: true,
                    opacity: 0.3,
                    blending: THREE.AdditiveBlending
                });
                const glow = new THREE.Mesh(glowGeometry, glowMaterial);
                group.add(glow);
            }
            
            return group;
        }

        // Enhanced Wall Creation
        function createWall(start, end, color) {
            const length = Math.sqrt(
                Math.pow(end.x - start.x, 2) + 
                Math.pow(end.z - start.z, 2)
            );
            const angle = Math.atan2(end.z - start.z, end.x - start.x);
            
            const geometry = new THREE.BoxGeometry(length, CONFIG.wallHeight, 0.3);
            const material = new THREE.MeshPhongMaterial({
                color: color,
                emissive: color,
                emissiveIntensity: 0.7,
                transparent: true,
                opacity: CONFIG.wallOpacity,
                blending: THREE.AdditiveBlending
            });
            
            const wall = new THREE.Mesh(geometry, material);
            wall.position.set(
                (start.x + end.x) / 2,
                CONFIG.wallHeight / 2,
                (start.z + end.z) / 2
            );
            wall.rotation.y = -angle;
            wall.castShadow = true;
            
            // Add pulse animation
            wall.userData.pulse = 0;
            
            return wall;
        }

        // Power-up Creation
        function createPowerUp(x, z) {
            const geometry = new THREE.TorusGeometry(0.8, 0.2, 8, 24);
            const material = new THREE.MeshPhongMaterial({
                color: 0x00ff00,
                emissive: 0x00aa00,
                emissiveIntensity: 0.8
            });
            
            const powerUp = new THREE.Mesh(geometry, material);
            powerUp.position.set(x, 1.5, z);
            powerUp.rotation.x = Math.PI / 2;
            powerUp.castShadow = true;
            
            // Add rotation animation
            powerUp.userData = {
                rotationSpeed: 0.02,
                pulseSpeed: 0.05,
                pulseSize: 0
            };
            
            scene.add(powerUp);
            gameState.powerUps.push(powerUp);
            
            return powerUp;
        }

        // Initialize Game
        function initGame() {
            scene.add(createGrid());
            createBuildings();
            
            // Create some power-ups
            for (let i = 0; i < 5; i++) {
                const x = Math.random() * CONFIG.gridSize - CONFIG.gridSize/2;
                const z = Math.random() * CONFIG.gridSize - CONFIG.gridSize/2;
                createPowerUp(x, z);
            }
            
            camera.position.set(0, CONFIG.cameraHeight, CONFIG.cameraDistance);
            camera.lookAt(0, 0, 0);
            
            // Start button
            document.getElementById('enter-button').addEventListener('click', startGame);
            
            // Enter key to start
            document.getElementById('player-name').addEventListener('keypress', (e) => {
                if (e.key === 'Enter') startGame();
            });
            
            // Keyboard controls
            window.addEventListener('keydown', (e) => {
                if (['ArrowUp','ArrowDown','ArrowLeft','ArrowRight','KeyW','KeyA','KeyS','KeyD','Space'].includes(e.code)) {
                    gameState.keys[e.code] = true;
                    e.preventDefault();
                }
            });
            
            window.addEventListener('keyup', (e) => {
                if (['ArrowUp','ArrowDown','ArrowLeft','ArrowRight','KeyW','KeyA','KeyS','KeyD','Space'].includes(e.code)) {
                    gameState.keys[e.code] = false;
                    e.preventDefault();
                }
            });
            
            // Mobile controls
            if (gameState.isMobile) {
                const setupMobileButton = (id, keyCode) => {
                    const btn = document.getElementById(id);
                    btn.addEventListener('touchstart', () => gameState.keys[keyCode] = true);
                    btn.addEventListener('touchend', () => gameState.keys[keyCode] = false);
                };
                
                setupMobileButton('up-btn', 'ArrowUp');
                setupMobileButton('left-btn', 'ArrowLeft');
                setupMobileButton('down-btn', 'ArrowDown');
                setupMobileButton('right-btn', 'ArrowRight');
            }
            
            // Handle window resize
            window.addEventListener('resize', onWindowResize);
            
            // Start game loop
            gameState.lastTime = performance.now();
            animate();
        }

        // Start Game
        function startGame() {
            const playerName = document.getElementById('player-name').value.trim() || 'USER';
            document.getElementById('start-screen').style.display = 'none';
            document.getElementById('game-ui').classList.add('active');
            document.querySelector('.player-name').textContent = playerName.toUpperCase();
            
            // Create player
            gameState.myPlayerId = 'player-' + Math.random().toString(36).substr(2, 9);
            const color = CONFIG.playerColors[0];
            gameState.players[gameState.myPlayerId] = {
                id: gameState.myPlayerId,
                name: playerName,
                x: 0,
                z: 0,
                color: color,
                model: createPlayer(color),
                direction: { x: 0, z: 0 },
                speed: CONFIG.moveSpeed,
                lastWallTime: 0,
                isBoosting: false,
                boostEndTime: 0,
                score: 0,
                wallsCreated: 0
            };
            scene.add(gameState.players[gameState.myPlayerId].model);
            
            // Add AI players with different behaviors
            addAIPlayer('RINZLER', -15, 0, CONFIG.playerColors[1], 'aggressive');
            addAIPlayer('QUORRA', 15, 0, CONFIG.playerColors[2], 'defensive');
            addAIPlayer('CLU', 0, -15, CONFIG.playerColors[3], 'random');
            addAIPlayer('TRON', 0, 15, 0xffffff, 'patrol');
            
            gameState.gameStarted = true;
            gameState.score = 0;
        }

        // Enhanced AI Player Creation
        function addAIPlayer(name, x, z, color, behavior = 'random') {
            const id = 'ai-' + Math.random().toString(36).substr(2, 9);
            gameState.players[id] = {
                id,
                name,
                x,
                z,
                color,
                model: createPlayer(color, true),
                direction: { 
                    x: Math.random() > 0.5 ? 1 : -1, 
                    z: Math.random() > 0.5 ? 1 : -1 
                },
                speed: CONFIG.moveSpeed * 0.7,
                lastTurn: 0,
                isAI: true,
                behavior,
                targetX: 0,
                targetZ: 0,
                wallsCreated: 0
            };
            
            // Set initial target based on behavior
            if (behavior === 'patrol') {
                gameState.players[id].targetX = Math.random() * CONFIG.gridSize - CONFIG.gridSize/2;
                gameState.players[id].targetZ = Math.random() * CONFIG.gridSize - CONFIG.gridSize/2;
            }
            
            scene.add(gameState.players[id].model);
        }

        // Game Loop
        function animate() {
            requestAnimationFrame(animate);
            
            const time = performance.now();
            const deltaTime = time - gameState.lastTime;
            gameState.lastTime = time;
            
            if (gameState.gameStarted) {
                // Update all game elements
                updatePlayers(deltaTime);
                updateWalls();
                updatePowerUps();
                checkCollisions();
                updateUI();
                
                // Update camera to follow player
                if (gameState.myPlayerId && gameState.players[gameState.myPlayerId]) {
                    const player = gameState.players[gameState.myPlayerId];
                    const cameraOffset = player.isBoosting ? 40 : 35;
                    const targetX = player.x;
                    const targetZ = player.z + cameraOffset;
                    
                    // Smooth camera movement
                    camera.position.x += (targetX - camera.position.x) * 0.1;
                    camera.position.z += (targetZ - camera.position.z) * 0.1;
                    camera.lookAt(player.x, 0, player.z);
                }
            }
            
            renderer.render(scene, camera);
        }

        // Enhanced Player Update
        function updatePlayers(deltaTime) {
            Object.values(gameState.players).forEach(player => {
                const oldX = player.x;
                const oldZ = player.z;
                
                // Handle player input
                if (player.id === gameState.myPlayerId) {
                    updateHumanPlayer(player);
                } else {
                    updateAIPlayer(player, deltaTime);
                }
                
                // Create wall segments
                if ((player.direction.x !== 0 || player.direction.z !== 0) && 
                    Date.now() - player.lastWallTime > 100) {
                    createWallSegment(player, oldX, oldZ);
                    player.lastWallTime = Date.now();
                    player.wallsCreated++;
                }
                
                // Update position
                const speedMultiplier = player.isBoosting ? CONFIG.speedBoostMultiplier : 1;
                player.x += player.direction.x * player.speed * speedMultiplier;
                player.z += player.direction.z * player.speed * speedMultiplier;
                player.model.position.set(player.x, 0, player.z);
                
                // Face direction
                if (player.direction.x !== 0 || player.direction.z !== 0) {
                    player.model.rotation.y = Math.atan2(player.direction.x, -player.direction.z);
                }
                
                // Check boost status
                if (player.isBoosting && Date.now() > player.boostEndTime) {
                    player.isBoosting = false;
                    if (player.id === gameState.myPlayerId) {
                        document.querySelector('.player-score').textContent = `SPEED: 100%`;
                    }
                }
            });
        }

        function updateHumanPlayer(player) {
            player.direction = { x: 0, z: 0 };
            
            // Keyboard controls
            if (gameState.keys['ArrowUp'] || gameState.keys['KeyW']) player.direction.z = -1;
            if (gameState.keys['ArrowDown'] || gameState.keys['KeyS']) player.direction.z = 1;
            if (gameState.keys['ArrowLeft'] || gameState.keys['KeyA']) player.direction.x = -1;
            if (gameState.keys['ArrowRight'] || gameState.keys['KeyD']) player.direction.x = 1;
            
            // Boost with spacebar
            if ((gameState.keys['Space'] || gameState.keys['ShiftLeft']) && !player.isBoosting) {
                player.isBoosting = true;
                player.boostEndTime = Date.now() + CONFIG.boostDuration;
                document.querySelector('.player-score').textContent = `SPEED: ${Math.floor(CONFIG.speedBoostMultiplier * 100)}%`;
            }
            
            // Normalize diagonal movement
            if (player.direction.x !== 0 && player.direction.z !== 0) {
                player.direction.x *= 0.7071;
                player.direction.z *= 0.7071;
            }
        }

        // Enhanced AI Behavior
        function updateAIPlayer(player, deltaTime) {
            player.lastTurn += deltaTime;
            
            // Different behaviors
            switch(player.behavior) {
                case 'aggressive':
                    // Try to chase player
                    if (gameState.myPlayerId && gameState.players[gameState.myPlayerId]) {
                        const target = gameState.players[gameState.myPlayerId];
                        const dx = target.x - player.x;
                        const dz = target.z - player.z;
                        const distance = Math.sqrt(dx*dx + dz*dz);
                        
                        if (distance < 30 && player.lastTurn > 1000) {
                            player.direction.x = dx / distance;
                            player.direction.z = dz / distance;
                            player.lastTurn = 0;
                        }
                    }
                    break;
                    
                case 'defensive':
                    // Avoid walls and stay in open areas
                    if (player.lastTurn > 500) {
                        // Simple wall avoidance
                        let newDirX = player.direction.x;
                        let newDirZ = player.direction.z;
                        
                        // Check for potential collisions
                        const lookAhead = 5;
                        const futureX = player.x + player.direction.x * lookAhead;
                        const futureZ = player.z + player.direction.z * lookAhead;
                        
                        if (Math.abs(futureX) > CONFIG.gridSize/2 - 5) {
                            newDirX = -player.direction.x;
                            newDirZ = Math.random() > 0.5 ? 1 : -1;
                        }
                        
                        if (Math.abs(futureZ) > CONFIG.gridSize/2 - 5) {
                            newDirZ = -player.direction.z;
                            newDirX = Math.random() > 0.5 ? 1 : -1;
                        }
                        
                        player.direction.x = newDirX;
                        player.direction.z = newDirZ;
                        player.lastTurn = 0;
                    }
                    break;
                    
                case 'patrol':
                    // Move between waypoints
                    const dx = player.targetX - player.x;
                    const dz = player.targetZ - player.z;
                    const distance = Math.sqrt(dx*dx + dz*dz);
                    
                    if (distance < 5 || player.lastTurn > 3000) {
                        player.targetX = Math.random() * CONFIG.gridSize - CONFIG.gridSize/2;
                        player.targetZ = Math.random() * CONFIG.gridSize - CONFIG.gridSize/2;
                        player.lastTurn = 0;
                    } else {
                        player.direction.x = dx / distance;
                        player.direction.z = dz / distance;
                    }
                    break;
                    
                default: // random
                    if (player.lastTurn > 2000 || Math.random() < 0.01) {
                        player.direction = {
                            x: Math.random() > 0.5 ? 1 : -1,
                            z: Math.random() > 0.5 ? 1 : -1
                        };
                        player.lastTurn = 0;
                    }
            }
            
            // Occasionally boost
            if (!player.isBoosting && Math.random() < 0.001) {
                player.isBoosting = true;
                player.boostEndTime = Date.now() + CONFIG.boostDuration;
            }
            
            // End boost
            if (player.isBoosting && Date.now() > player.boostEndTime) {
                player.isBoosting = false;
            }
        }

        // Create wall segments with better spacing
        function createWallSegment(player, oldX, oldZ) {
            const distance = Math.sqrt(
                Math.pow(player.x - oldX, 2) + 
                Math.pow(player.z - oldZ, 2)
            );
            
            // Only create wall if moved enough
            if (distance > CONFIG.wallSegmentDistance) {
                const wall = createWall(
                    { x: oldX, z: oldZ },
                    { x: player.x, z: player.z },
                    player.color
                );
                scene.add(wall);
                gameState.walls.push(wall);
                
                // Add to player score
                if (player.id === gameState.myPlayerId) {
                    gameState.score += Math.floor(distance);
                }
            }
        }

        // Update walls with effects
        function updateWalls() {
            // Clean up old walls
            if (gameState.walls.length > CONFIG.maxWalls) {
                const toRemove = gameState.walls.splice(0, 50);
                toRemove.forEach(wall => scene.remove(wall));
            }
            
            // Animate walls
            gameState.walls.forEach(wall => {
                wall.userData.pulse = (wall.userData.pulse + 0.05) % (Math.PI * 2);
                wall.material.opacity = CONFIG.wallOpacity * (0.9 + 0.1 * Math.sin(wall.userData.pulse));
            });
        }

        // Update power-ups
        function updatePowerUps() {
            gameState.powerUps.forEach(powerUp => {
                // Rotate and pulse
                powerUp.rotation.y += powerUp.userData.rotationSpeed;
                powerUp.userData.pulseSize = Math.sin(Date.now() * powerUp.userData.pulseSpeed) * 0.2;
                powerUp.scale.set(
                    1 + powerUp.userData.pulseSize,
                    1 + powerUp.userData.pulseSize,
                    1 + powerUp.userData.pulseSize
                );
            });
        }

        // Enhanced Collision Detection
        function checkCollisions() {
            Object.values(gameState.players).forEach(player => {
                // Check boundary collisions
                if (Math.abs(player.x) > CONFIG.gridSize/2 - 1 || 
                    Math.abs(player.z) > CONFIG.gridSize/2 - 1) {
                    handleCrash(player);
                    return;
                }
                
                // Check wall collisions
                for (let i = 0; i < gameState.walls.length; i++) {
                    const wall = gameState.walls[i];
                    const dx = player.x - wall.position.x;
                    const dz = player.z - wall.position.z;
                    const distance = Math.sqrt(dx*dx + dz*dz);
                    
                    // Simple distance check (could be improved with actual wall segment collision)
                    if (distance < 0.8) {
                        handleCrash(player);
                        break;
                    }
                }
                
                // Check power-up collisions
                for (let i = gameState.powerUps.length - 1; i >= 0; i--) {
                    const powerUp = gameState.powerUps[i];
                    const dx = player.x - powerUp.position.x;
                    const dz = player.z - powerUp.position.z;
                    const distance = Math.sqrt(dx*dx + dz*dz);
                    
                    if (distance < 1.5) {
                        // Collect power-up
                        scene.remove(powerUp);
                        gameState.powerUps.splice(i, 1);
                        
                        if (player.id === gameState.myPlayerId) {
                            // Speed boost
                            player.isBoosting = true;
                            player.boostEndTime = Date.now() + CONFIG.boostDuration;
                            document.querySelector('.player-score').textContent = 
                                `SPEED: ${Math.floor(CONFIG.speedBoostMultiplier * 100)}%`;
                            
                            // Add score
                            gameState.score += 100;
                            
                            // Create new power-up somewhere else
                            setTimeout(() => {
                                const x = Math.random() * CONFIG.gridSize - CONFIG.gridSize/2;
                                const z = Math.random() * CONFIG.gridSize - CONFIG.gridSize/2;
                                createPowerUp(x, z);
                            }, 3000);
                        }
                    }
                }
            });
        }

        // Enhanced Crash Handling
        function handleCrash(player) {
            // Visual effects
            player.model.traverse(child => {
                if (child.material) {
                    // Flash red
                    child.material.color.setHex(0xff0000);
                    child.material.emissive.setHex(0xff0000);
                    
                    // Reset after delay
                    setTimeout(() => {
                        if (child.material) {
                            child.material.color.setHex(player.color);
                            child.material.emissive.setHex(player.color);
                        }
                    }, 200);
                }
            });
            
            // Explosion particles
            createExplosion(player.x, 0, player.z, player.color);
            
            // Remove player after delay
            setTimeout(() => {
                scene.remove(player.model);
                delete gameState.players[player.id];
                
                // Game over if player crashed
                if (player.id === gameState.myPlayerId) {
                    endGame();
                }
            }, 300);
        }

        // Particle Explosion Effect
        function createExplosion(x, y, z, color) {
            const particles = 20;
            const explosionGroup = new THREE.Group();
            
            for (let i = 0; i < particles; i++) {
                const size = Math.random() * 0.5 + 0.2;
                const geometry = new THREE.SphereGeometry(size, 8, 8);
                const material = new THREE.MeshBasicMaterial({
                    color: color,
                    transparent: true,
                    opacity: 0.8,
                    blending: THREE.AdditiveBlending
                });
                
                const particle = new THREE.Mesh(geometry, material);
                particle.position.set(x, y, z);
                
                // Random direction and speed
                particle.userData = {
                    velocity: new THREE.Vector3(
                        (Math.random() - 0.5) * 0.2,
                        Math.random() * 0.1,
                        (Math.random() - 0.5) * 0.2
                    ),
                    lifetime: 0,
                    maxLifetime: 1000 + Math.random() * 500
                };
                
                explosionGroup.add(particle);
            }
            
            scene.add(explosionGroup);
            
            // Animate particles
            function updateParticles() {
                let allDead = true;
                explosionGroup.children.forEach(particle => {
                    if (particle.userData.lifetime < particle.userData.maxLifetime) {
                        particle.position.add(particle.userData.velocity);
                        particle.material.opacity = 0.8 * (1 - particle.userData.lifetime / particle.userData.maxLifetime);
                        particle.userData.lifetime += 16;
                        allDead = false;
                    }
                });
                
                if (!allDead) {
                    requestAnimationFrame(updateParticles);
                } else {
                    scene.remove(explosionGroup);
                }
            }
            
            updateParticles();
        }

        // Update UI Elements
        function updateUI() {
            if (gameState.myPlayerId && gameState.players[gameState.myPlayerId]) {
                const player = gameState.players[gameState.myPlayerId];
                document.getElementById('player-position').textContent = 
                    `${Math.floor(player.x)},${Math.floor(player.z)}`;
                document.getElementById('player-count').textContent = 
                    Object.keys(gameState.players).length;
                document.getElementById('trail-length').textContent = 
                    player.wallsCreated;
                
                // Update score if boosting
                if (player.isBoosting) {
                    const boostRemaining = Math.max(0, player.boostEndTime - Date.now());
                    const boostPercent = Math.floor((boostRemaining / CONFIG.boostDuration) * 100);
                    document.querySelector('.player-score').textContent = 
                        `SPEED: ${Math.floor(CONFIG.speedBoostMultiplier * 100)}% (${boostPercent}%)`;
                }
            }
        }

        // End Game
        function endGame() {
            alert(`GAME OVER\nSCORE: ${gameState.score}\nTRAIL LENGTH: ${gameState.players[gameState.myPlayerId]?.wallsCreated || 0}`);
            
            // Show start screen
            document.getElementById('start-screen').style.display = 'flex';
            document.getElementById('game-ui').classList.remove('active');
            gameState.gameStarted = false;
            
            // Reset game state
            gameState.players = {};
            gameState.walls.forEach(wall => scene.remove(wall));
            gameState.walls = [];
            gameState.powerUps.forEach(powerUp => scene.remove(powerUp));
            gameState.powerUps = [];
            
            // Clear scene
            while(scene.children.length > 0) { 
                scene.remove(scene.children[0]); 
            }
            
            // Reinitialize
            initGame();
        }

        // Window Resize Handler
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // Start the game
        initGame();
    </script>
</body>
</html>
