<!DOCTYPE html>
<html>
<head>
    <title>TRON 3D</title>
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            background: #000;
            color: #0FF;
            font-family: 'Courier New', monospace;
        }
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            padding: 10px;
            background: rgba(0,0,0,0.5);
        }
        #menu {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            background: rgba(0,0,0,0.8);
            padding: 20px;
            border: 2px solid #0FF;
        }
        button {
            background: #0066FF;
            color: white;
            border: 1px solid #0FF;
            padding: 10px 20px;
            margin: 10px;
            cursor: pointer;
            font-family: 'Courier New', monospace;
        }
    </style>
</head>
<body>
    <div id="info">
        ENERGY: <span id="energy">100</span>% | 
        SCORE: <span id="score">0</span> |
        ENEMIES: <span id="enemies">8</span>
    </div>
    
    <div id="menu">
        <h1>TRON 3D</h1>
        <p>Digital Frontier Simulation</p>
        <button id="startBtn">START GAME</button>
        <button id="fpBtn">FIRST PERSON MODE</button>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/controls/PointerLockControls.js"></script>
    <script>
// ===== TRON 3D WORLD =====
let scene, camera, renderer, controls;
let cycle, enemies = [];
let trails = [];
let gameActive = false;
let firstPerson = false;
let score = 0;
let energy = 100;

// Colors
const COLORS = {
    GRID: 0x00FFFF,
    CYCLE: 0x0066FF,
    TRAIL: 0x0066FF,
    ENEMY: 0xFF3300,
    ENEMY_TRAIL: 0xFF6600
};

// Initialize
function init() {
    // Scene
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x000000);
    scene.fog = new THREE.Fog(0x000000, 50, 200);

    // Camera
    camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
    camera.position.set(0, 10, 30);
    
    // Renderer
    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    // Lighting
    const ambient = new THREE.AmbientLight(0x404040);
    scene.add(ambient);
    
    const directional = new THREE.DirectionalLight(0xFFFFFF, 0.5);
    directional.position.set(1, 1, 1);
    scene.add(directional);

    // Grid
    createGrid();
    
    // Event listeners
    window.addEventListener('resize', onWindowResize);
    document.getElementById('startBtn').addEventListener('click', startGame);
    document.getElementById('fpBtn').addEventListener('click', startFirstPerson);
}

// Create the Tron grid
function createGrid() {
    const size = 100;
    const divisions = 50;
    const grid = new THREE.GridHelper(size, divisions, COLORS.GRID, COLORS.GRID);
    grid.material.opacity = 0.2;
    grid.material.transparent = true;
    scene.add(grid);
    
    // Add some "data towers"
    for (let i = 0; i < 10; i++) {
        const tower = new THREE.Mesh(
            new THREE.BoxGeometry(1, 5 + Math.random() * 10, 1),
            new THREE.MeshPhongMaterial({ 
                color: COLORS.GRID,
                emissive: COLORS.GRID,
                emissiveIntensity: 0.5
            })
        );
        tower.position.x = Math.random() * 80 - 40;
        tower.position.z = Math.random() * 80 - 40;
        tower.position.y = tower.geometry.parameters.height/2;
        scene.add(tower);
    }
}

// Create player's light cycle
function createCycle() {
    const geometry = new THREE.BoxGeometry(2, 1, 3);
    const material = new THREE.MeshPhongMaterial({
        color: COLORS.CYCLE,
        emissive: COLORS.CYCLE,
        emissiveIntensity: 0.8
    });
    cycle = new THREE.Mesh(geometry, material);
    cycle.position.y = 0.5;
    scene.add(cycle);
    
    // Add light
    const light = new THREE.PointLight(COLORS.CYCLE, 1, 10);
    cycle.add(light);
}

// Create enemy recognizers
function createEnemies(count) {
    for (let i = 0; i < count; i++) {
        const geometry = new THREE.ConeGeometry(2, 4, 4);
        const material = new THREE.MeshPhongMaterial({
            color: COLORS.ENEMY,
            emissive: COLORS.ENEMY,
            emissiveIntensity: 0.5
        });
        const enemy = new THREE.Mesh(geometry, material);
        
        // Position randomly
        enemy.position.x = Math.random() * 80 - 40;
        enemy.position.z = Math.random() * 80 - 40;
        enemy.position.y = 2;
        enemy.rotation.y = Math.random() * Math.PI * 2;
        
        // Add movement properties
        enemy.speed = 0.05 + Math.random() * 0.05;
        enemy.direction = new THREE.Vector3(
            Math.sin(enemy.rotation.y),
            0,
            Math.cos(enemy.rotation.y)
        );
        
        // Add to scene and array
        scene.add(enemy);
        enemies.push(enemy);
        
        // Add light
        const light = new THREE.PointLight(COLORS.ENEMY, 0.5, 15);
        enemy.add(light);
    }
}

// Start game
function startGame() {
    document.getElementById('menu').style.display = 'none';
    gameActive = true;
    
    // Create player and enemies
    createCycle();
    createEnemies(8);
    
    // Start game loop
    animate();
}

// First person mode
function startFirstPerson() {
    firstPerson = true;
    startGame();
    
    // Set up pointer lock controls
    controls = new THREE.PointerLockControls(camera, document.body);
    scene.add(controls.getObject());
    
    // Click to lock pointer
    document.addEventListener('click', function() {
        controls.lock();
    }, false);
}

// Game loop
function animate() {
    if (!gameActive) return;
    
    requestAnimationFrame(animate);
    
    // Move player
    if (cycle) {
        if (firstPerson) {
            // In first person mode, cycle follows camera
            cycle.position.copy(controls.getObject().position);
            cycle.position.y = 0.5;
            cycle.rotation.y = controls.getObject().rotation.y;
        } else {
            // Standard movement
            cycle.position.z -= 0.2;
            
            // Simple controls for demo
            if (keys['ArrowLeft'] || keys['a']) cycle.position.x -= 0.1;
            if (keys['ArrowRight'] || keys['d']) cycle.position.x += 0.1;
        }
        
        // Leave trail
        createTrailSegment(cycle.position, COLORS.TRAIL);
    }
    
    // Move enemies
    enemies.forEach(enemy => {
        // Simple AI: Change direction occasionally
        if (Math.random() < 0.01) {
            enemy.rotation.y = Math.random() * Math.PI * 2;
            enemy.direction.set(
                Math.sin(enemy.rotation.y),
                0,
                Math.cos(enemy.rotation.y)
            );
        }
        
        // Move in current direction
        enemy.position.x += enemy.direction.x * enemy.speed;
        enemy.position.z += enemy.direction.z * enemy.speed;
        
        // Leave trail
        createTrailSegment(enemy.position, COLORS.ENEMY_TRAIL);
        
        // Wrap around world
        if (enemy.position.x > 50) enemy.position.x = -50;
        if (enemy.position.x < -50) enemy.position.x = 50;
        if (enemy.position.z > 50) enemy.position.z = -50;
        if (enemy.position.z < -50) enemy.position.z = 50;
    });
    
    // Update HUD
    document.getElementById('score').textContent = score;
    document.getElementById('enemies').textContent = enemies.length;
    document.getElementById('energy').textContent = energy;
    
    renderer.render(scene, camera);
}

// Create trail segments
function createTrailSegment(position, color) {
    const geometry = new THREE.BoxGeometry(0.5, 0.1, 0.5);
    const material = new THREE.MeshPhongMaterial({
        color: color,
        emissive: color,
        emissiveIntensity: 0.3
    });
    const segment = new THREE.Mesh(geometry, material);
    segment.position.copy(position);
    segment.position.y = 0.05;
    scene.add(segment);
    trails.push(segment);
    
    // Limit trail length
    if (trails.length > 500) {
        const oldSegment = trails.shift();
        scene.remove(oldSegment);
    }
}

// Handle window resize
function onWindowResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
}

// Keyboard controls
const keys = {};
window.addEventListener('keydown', (e) => {
    keys[e.key] = true;
});
window.addEventListener('keyup', (e) => {
    keys[e.key] = false;
});

// Start the game
init();
    </script>
</body>
</html>
